/********************************* 深圳市航太电子有限公司 *******************************
* 实 验 名 ：超声波测距实验
* 实验说明 ：LCD1602实时显示超声波模块到遮挡物的距离
* 实验平台 ：航太51单片机开发板 V1.2
* 连接方式 ：跳线帽CN20 引脚3，5连接, 引脚4，6连接
* 注    意 ：1.烧录程序后，拿较平滑的物体，如书本遮挡到超声波模块前面并前后移动，会发现显示会有变化
             2.必须断开跳线帽CN26，否则LCD1602无法正常显示
* 作    者 ：航太电子产品研发部    QQ ：1909197536
* 店    铺 ：http://shop120013844.taobao.com/
****************************************************************************************/

#include <reg52.h>
#include <intrins.h>

#define FOSC 11059200L //晶振设置，默认使用11.0592M Hz
//#define FOSC 12000000L //晶振设置，使用12M Hz
//#define FOSC 24000000L //晶振设置，使用24M Hz

//IO接口定义
#define LCD_PORT P0
sbit lcd_rs=P3^5;
sbit lcd_en=P3^4;
sbit lcd_rw=P3^6;

sbit Trig = P3^2;//触发IO口
sbit Echo = P3^3;//返回IO口

//全局变量定义
unsigned char status = 0;//程序当前状态，1 发送触发信号，2 等待信号返回,3 
unsigned int dis_count = 0;//脉宽长计时
unsigned char count=0;
unsigned char code table1[]="Hantech MCU";
unsigned char code table2[]="Distance:";

/*******************************************************************************
* 函 数 名 ：Delayms
* 函数功能 ：实现 ms级的延时
* 输    入 ：ms
* 输    出 ：无
*******************************************************************************/
void Delayms(unsigned int ms)
{
	unsigned int i,j;
	for(i=0;i<ms;i++)
	#if FOSC == 11059200L
		for(j=0;j<114;j++);
	#elif FOSC == 12000000L
	  for(j=0;j<123;j++);
	#elif FOSC == 24000000L
		for(j=0;j<249;j++);
	#else
		for(j=0;j<114;j++);
	#endif
}

/*******************************************************************************
* 函 数 名 ：Delayus
* 函数功能 ：实现 us级的延时
* 输    入 ：us
* 输    出 ：无
*******************************************************************************/
void Delayus(unsigned int us)
{
	unsigned int i;
	for(i=0;i<us;i++);
}

/*******************************************************************************
* 函 数 名 ：LcdBusy
* 函数功能 ：检查LCD忙状态,LcdBusy 为1时，忙，等待。lcd-busy为0时,闲，可写指令与数据
* 输    入 ：无
* 输    出 ：状态
*******************************************************************************/
bit LcdBusy()
 {                          
    bit result;
    lcd_rs = 0;
    lcd_rw = 1;
    lcd_en = 1;
    Delayus(1);
    result = (bit)(P0&0x80);
    lcd_en = 0;
    return(result); 
}
 
/*******************************************************************************
* 函 数 名 ：LcdWriteCom
* 函数功能 ：LCD1602 写指令
* 输    入 ：无
* 输    出 ：无
*******************************************************************************/
void LcdWriteCom(unsigned char com)
{
	while(LcdBusy());
	LCD_PORT=com;
	lcd_rs=0;
	lcd_rw = 0;
	lcd_en=0;
	Delayus(5);
	lcd_en=1;
	Delayus(5);
	lcd_en=0;
	Delayus(5);
}

/*******************************************************************************
* 函 数 名 ：LcdWriteCom
* 函数功能 ：LCD1602 写数据
* 输    入 ：无
* 输    出 ：无
*******************************************************************************/
void LcdWriteDate(unsigned char date)
{
	while(LcdBusy());
	LCD_PORT=date;
	lcd_rs=1;
	lcd_rw = 0;
	lcd_en=0;
	Delayus(5);
	lcd_en=1;
	Delayus(5);
	lcd_en=0; 
	Delayus(5);	
}

/*******************************************************************************
* 函 数 名 ：LCD1602Init
* 函数功能 ：LCD1602初始化
* 输    入 ：无
* 输    出 ：无
*******************************************************************************/
void LCD1602Init()
{
	int a=0;
	LcdWriteCom(0x38);  //设置16*2显示，8位数据接口
	Delayms(20);
	LcdWriteCom(0x0c); //开显示,不显示光标
	Delayms(20);
	LcdWriteCom(0x06);//写一个指针自动加一
	Delayms(20);
	LcdWriteCom(0x01);//清屏
	Delayms(20);	

	Delayms(100);//延时一段时间时间，等待LCD1602稳定
	
	//写入初始文字
	LcdWriteCom(0x80);//设置第一行 数据地址指针，先存储在屏外
	Delayms(20);
	for(a=0;a<11;a++)
	{
	LcdWriteDate(table1[a]);	//写入数据
	Delayms(20);		
	}

	LcdWriteCom(0xc0);	//设置第二行 数据地址指针，先存储在屏外
	Delayms(50);
	for(a=0;a<9;a++)
	{
	LcdWriteDate(table2[a]);	//写入数据
	Delayms(20);		
	}
	LcdWriteCom(0xc0+13);
	LcdWriteDate('m');
	LcdWriteDate('m');//写入单位	
}

/*******************************************************************************
* 函 数 名 ：Init
* 函数功能 ：初始化
* 输    入 ：无
* 输    出 ：无
*******************************************************************************/
void Init()
{
	Trig = 0;
	TMOD=0x01;		   //设T0为方式1，GATE=1；
	TH0=0;
	TL0=0;  
	TR0 = 0;//关闭定时器	
	ET0=1;             //允许T0中断
	EX1=0;        //关闭外部中断1
	IT1=0;        //由高电平变低电平，触发外部中断
	EA=1;			   //开启总中断	
}	
/*******************************************************************************
* 函 数 名 ：main
* 函数功能 ：主函数
* 输    入 ：无
* 输    出 ：无
*******************************************************************************/
void main()
{
	LCD1602Init();
	Init();
	
	while(1)
	{
		
		unsigned char  count_ms = 0;
		if(status == 0)
		{
			//发送触发信号
			Trig = 1;
			status = 1;
			TH0 = 0;
			TL0 = 0;
			TR0 = 1;//打开定时器
			while(TL0 < 11);//延时超过10us
			status = 2;
			Trig = 0;
			TH0 = 0;
			TL0 = 0;
			TR0 = 0;
			while(Echo == 0);//等待回向信号起始位置
			EX1 = 1;//打开外部中断
			TR0 = 1;
			status = 3;//开始计算距离
	    }
		if(status == 4)//成功接收到数据
		{
			long distance;
			distance = (long)(dis_count) * 340/2000;//声速340m/s
			LcdWriteCom(0xc0+9);
			LcdWriteDate((distance/1000)%10 + '0');//千位
			LcdWriteDate((distance/100)%10 + '0');//百位
			LcdWriteDate((distance/10)%10 + '0');//十位
			LcdWriteDate(distance%10 + '0');//个位
			status = 0;//准备下次发送
		}
		if(status == 5)//接收数据失败
		{
			LcdWriteCom(0xc0+9);
			LcdWriteDate('-');
			LcdWriteDate('-');
			LcdWriteDate('-');
			LcdWriteDate('-');
			status = 0;//准备下次发送
		}
			Delayms(100);//延时100ms后就行下一次测距
	}
}

/*******************************************************************************
* 函 数 名 ：
* 函数功能 ：外部中断1服务函数
* 输    入 ：无
* 输    出 ：无
*******************************************************************************/
void Exint1Int()  interrupt 2   // 外部中断是2号
 { 
		if(status == 3)
		{
			 dis_count = TH0*256 + TL0;
			 EX1=0;            //关闭外部中断
			 TR0 = 0;
			 status = 4;
		}
  }
 
/*******************************************************************************
* 函 数 名 ：Timer0Int
* 函数功能 ：定时器0中断服务函数
* 输    入 ：无
* 输    出 ：无
*******************************************************************************/
void Timer0Int() interrupt 1  // 定时器0中断是1号
{
 TR0 = 0; 
 EX1=0; 
 status = 5;
}

